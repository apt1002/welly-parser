
/** RUST
struct Shared<T>(Rc<T>);

trait SequenceOfRc<T> {
    fn get(&self, i: usize) -> Rc<T> {
        self.borrow(i,
            |item: &Rc<T>| Shared(Rc::clone(item))
        ).0
    }

    fn borrow<U>(&self, i: usize, borrower: impl FnOnce(&Rc<T>) -> U) -> U {
        let item = self.get(i);
        borrower(&item)
    }
}
**/

obj SequenceShared[T] {
    fn len(&self): Int;

    fn get(&self, i: Int): $T {
        self.borrow(i,
            fn(&$item: T): Shared[T] { return ($item,); }
        ).0;
    };

    fn borrow[U](&self, i: Int, borrower: (fn(&$T): U)): U {
        $item = self.get(i);
        borrower(&item);
    }
}

obj SingleShared[T]($item: T) {
    fn new(T): Self {
        Self(T);
    }

    impl SequenceShared {
        fn len(&self) { 1; }

        // can omit if borrow present
        fn get(&self, i) {
            if i!=0 { panic(); }
            return $self.item; // would break if not shared
        }

        // can omit if get present
        fn borrow[U](&self, i, borrower) {
            if i!=0 { panic(); }
            borrower(&self.item); // would break if not shared
        }
    }
}
